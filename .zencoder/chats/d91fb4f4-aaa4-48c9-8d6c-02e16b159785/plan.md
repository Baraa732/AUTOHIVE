# Feature development workflow

---

## Workflow Steps

### [ ] Step: Requirements

Your job is to generate a Product Requirements Document based on the feature description,

First, analyze the provided feature definition and determine unclear aspects. For unclear aspects: - Make informed guesses based on context and industry standards - Only mark with [NEEDS CLARIFICATION: specific question] if: - The choice significantly impacts feature scope or user experience - Multiple reasonable interpretations exist with different implications - No reasonable default exists - Prioritize clarifications by impact: scope > security/privacy > user experience > technical details

Ask up to 5 most priority clarifications to the user. Then, create the document following this template:

```
# Feature Specification: [FEATURE NAME]


## User Stories*


### User Story 1 - [Brief Title]

**Acceptance Scenarios**:

1. **Given** [initial state], **When** [action], **Then** [expected outcome]
2. **Given** [initial state], **When** [action], **Then** [expected outcome]

---

## Requirements*

## Success Criteria*

```

Save the PRD into `c:\Users\Al Baraa\Desktop\Github Project\AUTOHIVE\.zencoder\chats\d91fb4f4-aaa4-48c9-8d6c-02e16b159785/requirements.md`.

### [ ] Step: Technical Specification

Based on the PRD in `c:\Users\Al Baraa\Desktop\Github Project\AUTOHIVE\.zencoder\chats\d91fb4f4-aaa4-48c9-8d6c-02e16b159785/requirements.md`, create a detailed technical specification to be used by a coding agent to implement the feature. Follow this template:

```
# Technical Specification: [FEATURE]

## Technical Context
Language/Version, primary dependencies, etc

## Technical Implementation Brief

Summarize key technical decisions for implementing the feature. Make sure they take into account the existing code as much as possible.

## Source Code Structure

## Contracts

Define addition or changes in data models, DB schemas, APIs, code interfaces etc

## Delivery Phases

Define several incremental deliverables for the feature. Each should be a minimal viable product testable end-to-end.

## Verification Strategy

Define how the coding agent can verify each deliverable it creates. Provide instructions for the agent to perform the verification using available tools (lint/test commands, bash commands) and create helper scripts and tools for more complex result verification.
The verification for each deliverable should be executable by a coding agent using built-in capabilities (lint and test commands from the project, bash commands), pre-generated helper scripts or MCP servers. Research and add to the spec:

- MCP servers that should be installed to help the agent with the verification

- helper scripts that need to be generated in the first phases of the plan to verify complex scenarios that can't be covered by the tests in the project's test framework(s)

- any sample input artifact(s) that are required for verification. Note if these artifacts can be a) generated by the agent; b) discovered by the agent on line; c) must be provided by the user.
```

Save the spec to `c:\Users\Al Baraa\Desktop\Github Project\AUTOHIVE\.zencoder\chats\d91fb4f4-aaa4-48c9-8d6c-02e16b159785/spec.md`.

### [x] Step: Requirements
✅ COMPLETED - Created requirements.md with user stories, functional requirements, and success criteria

### [x] Step: Technical Specification
✅ COMPLETED - Created spec.md with architecture, data contracts, and verification strategy

### [ ] Step: Implementation Plan

Based on the technical spec, here are the implementation tasks:

---

### [x] Step 1: Fix Backend Favorites API Response

**Task**: Remove the undefined landlord relationship from FavoriteController to fix RelationNotFoundException

**Contracts**: API Response Contract from spec.md

**Detailed Instructions**:
1. Open `c:\Users\Al Baraa\Desktop\Github Project\AUTOHIVE\server\app\Http\Controllers\Api\FavoriteController.php`
2. On line 13, change `with('apartment.landlord')` to `with('apartment')`
3. Ensure no other references to landlord in this controller
4. Test the endpoint returns proper apartment data without errors

**Deliverable**: 
- FavoriteController.php correctly loads apartment relationship only
- API endpoint returns valid JSON response with apartment data

**Verification**:
```bash
# Run artisan tinker test
php artisan tinker
>>> Favorite::with('apartment')->first();
# Should work without RelationNotFoundException

# Or test with API
GET http://localhost:8000/api/favorites
Authorization: Bearer {user_token}
# Should return 200 with valid apartment data
```

---

### [ ] Step 2: Fix Frontend Apartment Model Price Parsing

**Task**: Ensure Apartment model correctly parses price from both 'price' and 'price_per_night' fields

**Contracts**: Apartment model contract from spec.md

**Detailed Instructions**:
1. Review `c:\Users\Al Baraa\Desktop\Github Project\AUTOHIVE\client\lib\data\models\apartment.dart`
2. Current implementation already handles both price and price_per_night
3. Verify the model correctly handles null values and type conversions
4. No changes needed unless issues appear during testing

**Deliverable**:
- Apartment model parses API response correctly
- Price displays properly in UI

**Verification**:
```dart
// Test in Flutter
final apt = Apartment.fromJson(apiResponse['apartment']);
assert(apt.price > 0);
assert(apt.pricePerNight != null);
```

---

### [ ] Step 3: Enhance Favorites Screen UI

**Task**: Update FavoritesScreen to match home page apartment card design with filtering/sorting

**Contracts**: FavoritesScreen, Apartment model display contract

**Detailed Instructions**:
1. Open `c:\Users\Al Baraa\Desktop\Github Project\AUTOHIVE\client\lib\presentation\screens\shared\favorites_screen.dart`
2. Keep existing apartment card structure (it's already good)
3. Add filter/sort button in AppBar
4. Add FilterBottomSheet widget for filters and sorting options
5. Implement filtering logic on favoriteState
6. Add sorting dropdown/chips

**Detailed Enhancements**:
- Add IconButton to AppBar for filters
- Create FilterOptions class (or enum) for available filters
- Create SortOptions enum (date_added, price_asc, price_desc, rating)
- Show selected filters as chips below AppBar

**Deliverable**:
- Updated FavoritesScreen.dart with filter/sort UI
- FilterBottomSheet.dart (new file)
- Apartment cards styled consistently with home page

**Verification**:
```bash
# Run on Flutter device/emulator
flutter run
# Navigate to Favorites screen
# Verify: card layout matches home page
# Verify: filters button appears in AppBar
# Verify: filters open bottom sheet
```

---

### [ ] Step 4: Enhance Favorite Provider with Filter/Sort Logic

**Task**: Add filtering and sorting capabilities to FavoriteNotifier state management

**Contracts**: FavoriteState with filters/sort parameters

**Detailed Instructions**:
1. Open `c:\Users\Al Baraa\Desktop\Github Project\AUTOHIVE\client\lib\presentation\providers\favorite_provider.dart`
2. Extend FavoriteState to include:
   - `Map<String, dynamic> filters` (price_min, price_max, bedrooms, bathrooms, governorate, city)
   - `String sortBy` (date_added, price, rating)
   - `bool sortAscending`
3. Add methods to FavoriteNotifier:
   - `setFilters(filters)`
   - `setSorting(sortBy, ascending)`
   - `getFilteredAndSortedFavorites()` - returns filtered/sorted list
4. Implement filtering logic (compare apartment properties with filters)
5. Implement sorting logic (sort by created_at, price, or rating)

**Deliverable**:
- Enhanced FavoriteState class
- Filter and sort methods in FavoriteNotifier
- Filtered/sorted favorites returned to UI

**Verification**:
```dart
// Test filtering
ref.read(favoriteProvider.notifier).setFilters({
  'price_max': 150,
  'bedrooms': 2,
});
// Verify filtered list contains only apartments matching criteria

// Test sorting
ref.read(favoriteProvider.notifier).setSorting('price', true);
// Verify list sorted by price ascending
```

---

### [ ] Step 5: Create Filter UI Component

**Task**: Create FilterBottomSheet widget for user-friendly filter selection

**Contracts**: FavoriteState filters contract

**Detailed Instructions**:
1. Create new file: `c:\Users\Al Baraa\Desktop\Github Project\AUTOHIVE\client\lib\presentation\screens\shared\filter_bottom_sheet.dart`
2. Build FilterBottomSheet as a StatefulWidget
3. Include:
   - Price range slider (min/max)
   - Bedroom count selector (1-5+)
   - Bathroom count selector (1-5+)
   - Governorate dropdown
   - City dropdown (filtered by governorate)
   - Sort options (radio buttons or dropdown)
4. Add Apply/Reset buttons
5. Pass selected filters back to parent via callback

**Deliverable**:
- FilterBottomSheet.dart component
- Proper state management with selections
- Clean UI with material design

**Verification**:
```bash
# Run Flutter app
# Open Favorites → tap Filter
# Verify: all filter controls are accessible
# Verify: selections update favorites list
# Verify: Reset clears all filters
```

---

### [ ] Step 6: Add Favorite Button to Apartment Details

**Task**: Add favorite/unfavorite button to apartment details screen to toggle favorites

**Contracts**: FavoriteProvider add/remove methods

**Detailed Instructions**:
1. Find apartment_details_screen.dart in your presentation screens
2. Add favorite button to AppBar or detail section
3. Use FavoriteProvider to check if current apartment is favorited
4. Implement toggle logic:
   - If favorited: show filled heart icon, clicking removes from favorites
   - If not favorited: show outline heart icon, clicking adds to favorites
5. Show toast/snackbar feedback on success/error

**Deliverable**:
- Favorite button integrated in apartment details
- Icon toggles based on favorite status
- Add/remove from favorites works smoothly

**Verification**:
```bash
# Navigate to apartment details
# Verify: heart icon shown
# Tap heart: apartment added to favorites
# Navigate to favorites: apartment appears in list
# Return to details: heart icon is filled
# Tap heart again: apartment removed
# Check favorites: apartment gone from list
```

---

### [ ] Step 7: Update Home Page Apartment Cards with Favorite Status

**Task**: Show favorite status on apartment cards in home page and update when toggled

**Contracts**: FavoriteProvider isFavorite() method

**Detailed Instructions**:
1. Find home/listings screen showing apartment cards
2. For each apartment card, add favorite icon
3. Use `ref.watch(favoriteProvider)` to check if apartment is favorited
4. Color icon differently if favorited (red/filled vs gray/outline)
5. Add tap handler to toggle favorite
6. Ensure UI updates immediately

**Deliverable**:
- Home page apartment cards show favorite status
- Favorite icon toggles correctly
- Favorite status syncs across screens

**Verification**:
```bash
# Home page loads
# Verify: apartments show favorite icons
# Favorite apartment from home page
# Navigate to Favorites: apartment appears
# Back to home: heart icon is filled
# Remove from favorites on home page
# Heart icon becomes outline
```

---

### [ ] Step 8: Integration Testing - Complete Favorites Flow

**Task**: Test entire favorites feature from add to remove across all screens

**Detailed Instructions**:
1. Start fresh: clear favorites on backend
2. Open home page: verify no apartments are favorited
3. Favorite 3-5 apartments from home page
4. Navigate to Favorites screen:
   - All favorited apartments display correctly
   - Images load properly
   - Location, beds, baths, price show
5. Test filtering:
   - Filter by price: list updates
   - Filter by bedrooms: list updates
   - Reset filters: shows all again
6. Test sorting:
   - Sort by price: list reorders
   - Sort by date: shows newest first
7. Remove favorite from Favorites screen: updates immediately
8. Navigate to apartment details: heart is outline (no longer favorited)
9. Back to home: heart icon is outline
10. Add to favorites again: appears in Favorites list

**Deliverable**:
- Complete end-to-end flow tested
- No errors or crashes
- All features work as expected

**Verification**:
```bash
# Manual testing steps above
# Check logs: no RelationNotFoundException
# Check logs: no parsing errors
# UI renders smoothly
# Navigation works
```

---

### [ ] Step 9: Performance and Error Handling Review

**Task**: Ensure robust error handling and good performance

**Detailed Instructions**:
1. Review error messages shown to users
2. Add proper error handling for:
   - Network timeouts
   - Invalid responses
   - Parsing errors
3. Ensure loading states display correctly
4. Test with slow network (use Flutter DevTools)
5. Verify pagination works if many favorites
6. Ensure images lazy load/cache properly

**Deliverable**:
- Robust error handling throughout
- User-friendly error messages
- Good performance with many favorites

**Verification**:
```bash
# Disable network: see proper error message
# Slow 3G network: loading indicators show
# Many favorites: list scrolls smoothly
# Pull to refresh: works correctly
```

---

### [ ] Step 10: Final Code Quality Check

**Task**: Ensure code follows project conventions and is production-ready

**Detailed Instructions**:
1. Run Flutter analysis: `flutter analyze`
2. Run Dart formatter: `dart format .`
3. Check for any console warnings/errors
4. Remove debug print statements
5. Verify all imports are used
6. Code review checklist:
   - Consistent naming conventions
   - Proper null safety
   - Error handling in place
   - Comments where needed
   - No hardcoded values
   - State management clean

**Deliverable**:
- Clean code with no warnings
- Follows project conventions
- Production-ready implementation

**Verification**:
```bash
flutter analyze
# Should show no issues

dart format .
# Should format without changes

flutter build apk --debug
# Should build without errors
```

---
