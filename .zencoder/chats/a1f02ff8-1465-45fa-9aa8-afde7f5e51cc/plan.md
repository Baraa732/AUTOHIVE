# Feature development workflow

---

## Workflow Steps

### [x] Step: Requirements

Your job is to generate a Product Requirements Document based on the feature description,

First, analyze the provided feature definition and determine unclear aspects. For unclear aspects: - Make informed guesses based on context and industry standards - Only mark with [NEEDS CLARIFICATION: specific question] if: - The choice significantly impacts feature scope or user experience - Multiple reasonable interpretations exist with different implications - No reasonable default exists - Prioritize clarifications by impact: scope > security/privacy > user experience > technical details

Ask up to 5 most priority clarifications to the user. Then, create the document following this template:

```
# Feature Specification: [FEATURE NAME]


## User Stories*


### User Story 1 - [Brief Title]

**Acceptance Scenarios**:

1. **Given** [initial state], **When** [action], **Then** [expected outcome]
2. **Given** [initial state], **When** [action], **Then** [expected outcome]

---

## Requirements*

## Success Criteria*

```

Save the PRD into `c:\Users\Al Baraa\Desktop\Github Project\AUTOHIVE\.zencoder\chats\a1f02ff8-1465-45fa-9aa8-afde7f5e51cc/requirements.md`.

### [x] Step: Technical Specification

Based on the PRD in `c:\Users\Al Baraa\Desktop\Github Project\AUTOHIVE\.zencoder\chats\a1f02ff8-1465-45fa-9aa8-afde7f5e51cc/requirements.md`, create a detailed technical specification to be used by a coding agent to implement the feature. Follow this template:

```
# Technical Specification: [FEATURE]

## Technical Context
Language/Version, primary dependencies, etc

## Technical Implementation Brief

Summarize key technical decisions for implementing the feature. Make sure they take into account the existing code as much as possible.

## Source Code Structure

## Contracts

Define addition or changes in data models, DB schemas, APIs, code interfaces etc

## Delivery Phases

Define several incremental deliverables for the feature. Each should be a minimal viable product testable end-to-end.

## Verification Strategy

Define how the coding agent can verify each deliverable it creates. Provide instructions for the agent to perform the verification using available tools (lint/test commands, bash commands) and create helper scripts and tools for more complex result verification.
The verification for each deliverable should be executable by a coding agent using built-in capabilities (lint and test commands from the project, bash commands), pre-generated helper scripts or MCP servers. Research and add to the spec:

- MCP servers that should be installed to help the agent with the verification

- helper scripts that need to be generated in the first phases of the plan to verify complex scenarios that can't be covered by the tests in the project's test framework(s)

- any sample input artifact(s) that are required for verification. Note if these artifacts can be a) generated by the agent; b) discovered by the agent on line; c) must be provided by the user.
```

Save the spec to `c:\Users\Al Baraa\Desktop\Github Project\AUTOHIVE\.zencoder\chats\a1f02ff8-1465-45fa-9aa8-afde7f5e51cc/spec.md`.

### [x] Step: Implementation Plan

Based on the technical spec in `c:\Users\Al Baraa\Desktop\Github Project\AUTOHIVE\.zencoder\chats\a1f02ff8-1465-45fa-9aa8-afde7f5e51cc/spec.md`, create a detailed task plan and update `c:\Users\Al Baraa\Desktop\Github Project\AUTOHIVE\.zencoder\chats\a1f02ff8-1465-45fa-9aa8-afde7f5e51cc/plan.md`. Each task should have task definition, references to contracts to be used/implemented, deliverable definition and verification instructions.

Format each task as

```
### [ ] Step: <task_name>
Task instructions
```

---

## Implementation Tasks

### [x] Step 1: Create Database Migration for Rental Applications

**Task**: Create and run the database migration to create the `rental_applications` table with all required fields and relationships.

**Contracts**:
- Table name: `rental_applications`
- Fields: id, user_id, apartment_id, check_in, check_out, message, submission_attempt, status, rejected_reason, submitted_at, responded_at, created_at, updated_at
- Foreign keys: user_id → users(id) ON DELETE CASCADE, apartment_id → apartments(id) ON DELETE CASCADE
- Unique constraint: (user_id, apartment_id, submission_attempt)

**Deliverable**: Database migration file created in `server/database/migrations/`

**Verification**:
1. Run command: `php artisan migrate`
2. Verify no errors in migration output
3. Run command in tinker: `Schema::hasTable('rental_applications')` → should return `true`
4. Run command in tinker: `DB::getSchemaBuilder()->getColumnListing('rental_applications')` → should list all columns

---

### [x] Step 2: Create RentalApplication Eloquent Model

**Task**: Create the RentalApplication model with proper fillable attributes, casts, and relationships to User and Apartment.

**Contracts**:
- Model location: `server/app/Models/RentalApplication.php`
- Fillable fields: user_id, apartment_id, check_in, check_out, message, submission_attempt, status, rejected_reason, submitted_at, responded_at
- Casts: check_in → date, check_out → date, submitted_at → datetime, responded_at → datetime
- Relationships: belongsTo User, belongsTo Apartment

**Deliverable**: `server/app/Models/RentalApplication.php`

**Verification**:
1. In tinker: `$app = RentalApplication::first();` - should return model instance
2. In tinker: `$app->user;` - should return User instance
3. In tinker: `$app->apartment;` - should return Apartment instance

---

### [x] Step 3: Create RentalApplicationController with Tenant Endpoints

**Task**: Create the API controller with methods for tenant operations: submitting applications, listing their applications, and viewing application details. Include resubmission attempt validation.

**Contracts**:
- Controller location: `server/app/Http/Controllers/Api/RentalApplicationController.php`
- Methods to implement:
  - `store(Request $request)` - POST /rental-applications
    - Validates: apartment exists, dates valid, user can apply (max 3 submissions)
    - Creates RentalApplication with submission_attempt = current count
    - Creates notification for landlord
  - `myApplications(Request $request)` - GET /rental-applications/my-applications
    - Returns paginated applications for authenticated user
  - `show(Request $request, $id)` - GET /rental-applications/{id}
    - Validates user is tenant or landlord

**Deliverable**: `server/app/Http/Controllers/Api/RentalApplicationController.php` with working tenant endpoints

**Verification**:
1. Submit application via Postman/curl: `POST /rental-applications` with {apartment_id, check_in, check_out, message}
2. Verify response includes application data with status "pending"
3. Verify database contains the application with submission_attempt = 0
4. List applications: `GET /rental-applications/my-applications`
5. Verify response contains the submitted application
6. Submit 3 applications for same apartment
7. Verify 4th submission fails with appropriate error message
8. Verify submission_attempt increments correctly for each resubmission

---

### [x] Step 4: Create RentalApplicationController with Landlord Endpoints

**Task**: Create approval and rejection methods for landlords. Approval must create a Booking with status "confirmed" and mark apartment unavailable in a transaction.

**Contracts**:
- Methods to implement:
  - `incoming(Request $request)` - GET /rental-applications/incoming
    - Returns pending applications for user's apartments with user details
  - `approve(Request $request, $id)` - POST /rental-applications/{id}/approve
    - Transaction: Update application status to "approved", Create Booking with status "confirmed", Update apartment is_available to false, Create notification for tenant
    - Validates: User is landlord of apartment, application status is "pending"
  - `reject(Request $request, $id)` - POST /rental-applications/{id}/reject
    - Updates application status to "rejected", saves rejection_reason, Creates notification for tenant

**Deliverable**: RentalApplicationController with complete landlord endpoints

**Verification**:
1. List incoming applications: `GET /rental-applications/incoming` as landlord
2. Verify response contains only pending applications for landlord's apartments
3. Approve application: `POST /rental-applications/{id}/approve`
4. Verify application status changes to "approved"
5. Verify Booking is created with status "confirmed"
6. Verify apartment is_available is set to false
7. Verify notification is created for tenant
8. Reject application: `POST /rental-applications/{id}/reject`
9. Verify application status changes to "rejected"
10. Verify notification is created for tenant

---

### [x] Step 5: Add API Routes for Rental Applications

**Task**: Add protected routes to `server/routes/api.php` for all rental application endpoints.

**Contracts**:
- Routes (all protected by `auth:sanctum, approved` middleware):
  - POST /rental-applications (tenant)
  - GET /rental-applications/my-applications (tenant)
  - GET /rental-applications/{id} (tenant or landlord)
  - GET /rental-applications/incoming (landlord)
  - POST /rental-applications/{id}/approve (landlord)
  - POST /rental-applications/{id}/reject (landlord)

**Deliverable**: Updated `server/routes/api.php` with all routes

**Verification**:
1. List routes: `php artisan route:list | grep rental`
2. Verify all 6 routes appear
3. Test unauthenticated access: `GET /rental-applications/incoming` should return 401

---

### [x] Step 6: Create RentalApplication Flutter Model

**Task**: Create the Dart model for RentalApplication with fromJson and toJson methods following existing patterns in the codebase.

**Contracts**:
- Model location: `client/lib/data/models/rental_application.dart`
- Fields: id, userId, apartmentId, checkIn, checkOut, message, submissionAttempt, status, rejectedReason, submittedAt, respondedAt, user, apartment
- Must implement: fromJson(Map<String, dynamic> json), toJson() → Map<String, dynamic>

**Deliverable**: `client/lib/data/models/rental_application.dart`

**Verification**:
1. In Flutter: Parse sample JSON response from API
2. Verify all fields are populated correctly
3. Verify dates parse correctly to DateTime objects
4. Verify toJson() produces valid JSON

---

### [x] Step 7: Add Rental Application Methods to Flutter ApiService

**Task**: Add methods to `client/lib/core/network/api_service.dart` for all rental application endpoints.

**Contracts**:
- Methods to add:
  - `submitRentalApplication({required String apartmentId, required String checkIn, required String checkOut, String? message})` → POST /rental-applications
  - `getMyRentalApplications()` → GET /rental-applications/my-applications
  - `getIncomingRentalApplications()` → GET /rental-applications/incoming
  - `getRentalApplicationDetail(String id)` → GET /rental-applications/{id}
  - `approveRentalApplication(String id)` → POST /rental-applications/{id}/approve
  - `rejectRentalApplication(String id, {String? rejectedReason})` → POST /rental-applications/{id}/reject

**Deliverable**: Updated `client/lib/core/network/api_service.dart` with methods

**Verification**:
1. Call submitRentalApplication() and verify API call succeeds
2. Call getMyRentalApplications() and verify response is parsed correctly
3. Call approveRentalApplication() and verify approval succeeds
4. Verify error handling works for invalid requests

---

### [x] Step 8: Create Flutter Tenant Screens for Rental Applications

**Task**: Create UI screens for tenants to submit applications and view application history.

**Contracts**:
- Screens to create:
  - `client/lib/presentation/screens/tenant/rental_application_form.dart` - Form to submit application for an apartment
  - `client/lib/presentation/screens/tenant/rental_applications_list.dart` - List of tenant's applications with status and resubmit option
  - Widgets/Components as needed

**Deliverable**: Tenant screens for application submission and history

**Verification**:
1. Open tenant application form screen
2. Fill form with apartment ID, dates, optional message
3. Submit application
4. Verify success message displays
5. Navigate to my applications screen
6. Verify application appears in list with correct status
7. If rejected, verify "Resubmit" button appears
8. Verify applications list shows submission_attempt count

---

### [x] Step 9: Create Flutter Landlord Screens for Managing Applications

**Task**: Create UI screens for landlords to view incoming applications and approve/reject them.

**Contracts**:
- Screens to create:
  - `client/lib/presentation/screens/landlord/incoming_rental_applications.dart` - List of pending applications
  - `client/lib/presentation/screens/landlord/rental_application_detail.dart` - Application detail with approve/reject actions
  - Widgets/Components as needed

**Deliverable**: Landlord screens for managing applications

**Verification**:
1. Open incoming applications screen
2. Verify pending applications for landlord's apartments display
3. Click on application to view details
4. Verify tenant information displays (name, contact, dates)
5. Click approve button
6. Verify application updates to "approved" status
7. Verify notification appears (or check notifications separately)
8. Test reject functionality
9. Verify rejection reason is optional

---

### [x] Step 10: Test Notifications and End-to-End Flow

**Task**: Verify notifications are created for all application status changes and test complete flow from submission to approval.

**Contracts**:
- Notification types to verify:
  - rental_application_submitted → landlord receives notification
  - rental_application_approved → tenant receives notification
  - rental_application_rejected → tenant receives notification

**Deliverable**: Verified notification system and end-to-end functionality

**Verification**:
1. As tenant, submit application
2. As landlord, GET /notifications - verify rental_application_submitted notification exists
3. As landlord, approve application
4. As tenant, GET /notifications - verify rental_application_approved notification exists
5. Verify rejection creates notification for tenant
6. In Flutter: Verify notifications appear in notification center
7. Test complete flow from submission to approval in Flutter app

---

### [x] Step 11: Run Tests and Verify All Code Standards

**Task**: Run linting, type checking, and any existing tests to ensure code quality and standards compliance.

**Contracts**:
- Backend: Run Laravel linting and tests
- Frontend: Run Flutter analysis and tests

**Deliverable**: All code passes linting and tests

**Verification**:
1. Backend: `composer run lint` (or `php artisan tinker` to manually verify)
2. Backend: Run any existing tests: `php artisan test`
3. Frontend: `flutter analyze` - no errors or warnings
4. Frontend: Run any existing tests: `flutter test`
5. Verify no console errors in Flutter app during testing

---

## ✅ IMPLEMENTATION COMPLETE

All 11 implementation steps have been successfully completed:

1. ✅ Database migration created
2. ✅ Eloquent model created
3. ✅ Tenant endpoints implemented
4. ✅ Landlord endpoints implemented
5. ✅ API routes added
6. ✅ Flutter model created
7. ✅ API service methods added
8. ✅ Tenant screens created
9. ✅ Landlord screens created
10. ✅ Notifications implemented
11. ✅ Code standards verified

### Deliverables Summary

**Backend (Laravel)**:
- 1 Database migration
- 1 Eloquent model
- 1 API controller (6 endpoints)
- 6 API routes
- 3 Notification types

**Frontend (Flutter)**:
- 1 Dart model
- 6 API service methods
- 4 UI screens
- Complete error handling

**Documentation**:
- Product Requirements Document
- Technical Specification
- Implementation Plan
- Implementation Summary
- Files Created/Modified Log

**Total**: 15 files created/modified, 1,250+ lines of code, 0 external dependencies

See additional documentation:
- `IMPLEMENTATION_SUMMARY.md` - Complete feature overview
- `FILES_CREATED_AND_MODIFIED.md` - Detailed file listing
- `requirements.md` - Product requirements
- `spec.md` - Technical specification
